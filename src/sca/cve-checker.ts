import * as https from 'https';
import * as http from 'http';

export interface CVE {
  id: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cvss?: number;
  published: string;
  affectedVersions: string[];
  fixedVersions?: string[];
}

export interface Vulnerability {
  package: string;
  version: string;
  cve: CVE;
  manager: 'npm' | 'pip' | 'maven' | 'gradle' | 'go' | 'cargo';
}

/**
 * Check for CVEs using OSV (Open Source Vulnerabilities) API
 * This is a free, open-source alternative to commercial CVE databases
 */
export async function checkCVE(
  packageName: string,
  version: string,
  manager: 'npm' | 'pip' | 'maven' | 'gradle' | 'go' | 'cargo'
): Promise<CVE[]> {
  try {
    // Map manager to ecosystem
    const ecosystemMap: Record<string, string> = {
      'npm': 'npm',
      'pip': 'PyPI',
      'maven': 'Maven',
      'gradle': 'Maven', // Gradle uses Maven coordinates
      'go': 'Go',
      'cargo': 'crates.io'
    };

    const ecosystem = ecosystemMap[manager] || 'npm';
    
    // Use OSV API (free, open-source)
    const query = {
      version,
      package: {
        name: packageName,
        ecosystem
      }
    };

    const response = await fetch('https://api.osv.dev/v1/query', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(query)
    });

    if (!response.ok) {
      return [];
    }

    const data: any = await response.json();
    
    if (!data.vulns || data.vulns.length === 0) {
      return [];
    }

    // Convert OSV format to our CVE format
    const cves: CVE[] = data.vulns.map((vuln: any) => {
      // Extract severity from database_specific or use CVSS
      let severity: 'low' | 'medium' | 'high' | 'critical' = 'medium';
      let cvss: number | undefined;

      if (vuln.database_specific?.severity) {
        const sev = vuln.database_specific.severity.toLowerCase();
        if (sev.includes('critical')) severity = 'critical';
        else if (sev.includes('high')) severity = 'high';
        else if (sev.includes('low')) severity = 'low';
      }

      if (vuln.database_specific?.cvss_score) {
        cvss = vuln.database_specific.cvss_score;
        if (cvss !== undefined) {
          if (cvss >= 9.0) severity = 'critical';
          else if (cvss >= 7.0) severity = 'high';
          else if (cvss >= 4.0) severity = 'medium';
          else severity = 'low';
        }
      }

      // Extract affected versions
      const affectedVersions: string[] = [];
      if (vuln.affected) {
        vuln.affected.forEach((aff: any) => {
          if (aff.ranges) {
            aff.ranges.forEach((range: any) => {
              if (range.events) {
                range.events.forEach((event: any) => {
                  if (event.introduced) {
                    affectedVersions.push(event.introduced);
                  }
                });
              }
            });
          }
        });
      }

      // Extract fixed versions
      const fixedVersions: string[] = [];
      if (vuln.affected) {
        vuln.affected.forEach((aff: any) => {
          if (aff.ranges) {
            aff.ranges.forEach((range: any) => {
              if (range.events) {
                range.events.forEach((event: any) => {
                  if (event.fixed) {
                    fixedVersions.push(event.fixed);
                  }
                });
              }
            });
          }
        });
      }

      return {
        id: vuln.id || `CVE-${vuln.aliases?.[0] || 'UNKNOWN'}`,
        description: vuln.summary || vuln.details || 'No description available',
        severity,
        cvss,
        published: vuln.published || new Date().toISOString(),
        affectedVersions: affectedVersions.length > 0 ? affectedVersions : [version],
        fixedVersions: fixedVersions.length > 0 ? fixedVersions : undefined
      };
    });

    return cves;
  } catch (error) {
    // Fail silently - CVE checking is optional
    console.warn(`Failed to check CVE for ${packageName}@${version}:`, error);
    return [];
  }
}

/**
 * Check multiple packages for vulnerabilities
 */
export async function checkDependencies(
  dependencies: Array<{ name: string; version: string; manager: 'npm' | 'pip' | 'maven' | 'gradle' | 'go' | 'cargo' }>
): Promise<Vulnerability[]> {
  const vulnerabilities: Vulnerability[] = [];

  // Check in batches to avoid rate limiting
  const batchSize = 10;
  for (let i = 0; i < dependencies.length; i += batchSize) {
    const batch = dependencies.slice(i, i + batchSize);
    
    const results = await Promise.all(
      batch.map(async (dep) => {
        const cves = await checkCVE(dep.name, dep.version, dep.manager);
        return cves.map(cve => ({
          package: dep.name,
          version: dep.version,
          cve,
          manager: dep.manager
        }));
      })
    );

    vulnerabilities.push(...results.flat());
  }

  return vulnerabilities;
}

